<!DOCTYPE html>
<html>
<head>
  <title>
    WIKI
  </title>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
</head>
<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="#">OS simulator</a>
    </div>
    <ul class="nav navbar-nav">
      <li class="active"><a href="index.html">Home</a></li>
      <li class="active"><a href="#">Wiki</a></li>
    </ul>
  </div>
</nav>
<br><br><br>

<body>
  <h1>Introduction</h1>

  <h2> Basic Concepts</h2>
  <h3> CPU-I/O Burst Cycle</h3>
  <p>Process execution consists of a cycle of CPU execution and I/O wait. Processes alternate between these two states. Process execution begins with a CPU burst. That is followed by an I/O burst, which is followed by another CPU burst, then another I/O burst, and so on. Eventually, the final CPU burst ends with a system request to terminate execution.</p>
  <h3>CPU Scheduler</h3>
  <p>Whenever the CPU becomes idle, the operating system must select one of the processes in the ready queue to be executed. The selection process is carried out by the short-term scheduler, or CPU scheduler. The scheduler selects a process from the processes in memory that are ready to execute and allocates the CPU to that process.</p>
  <h3>Dispatcher</h3>
  <p>The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler. This function involves the following:<br>

Switching context<br>
Switching to user mode<br>
Jumping to the proper location in the user program to restart that program<br></p>
<h2>First Come First Serve</h2>
<h3>Description</h3>
<p>The simplest of all scheduling algorithms. The process that requested the CPU first is allocated the CPU first.</p>
<h3>Demerits</h3>
<p>1.Average waiting time under FCFS policy is quite long.<br>
2.A smaller process has to wait for a large amount of time before a bigger process that has been allocated CPU finishes its execution.<br>
3.Not suitable for time sharing systems where each user gets a share of CPU at regular intervals.<br>
</p>
<h2>Shortest Job Scheduling</h2>
<h3>Description</h3>
<p>The scheduling criteria under this policy depends on which process has the shortest-next-CPU-burst. It is an optimal way of CPU scheduling, i.e it gives the minimum average waiting time for a set of processes. If two process have the same burst time left, FCFS is used to resolve the tie.</p>
<h3>Demerits</h3>
<p>1.It often cannot be implemented at the level of short-term CPU scheduling as there is no way to know the length of the next CPU burst.<br>
2.The next CPU burst length is thereby approximated using statistical techniques like exponential average<br></p>
<h2>Shortest Remaining Time First</h2>
<p>This is the preemptive version of Shortest Job First scheduling. A newly arrived process in the ready queue may have a burst time lesser than that of the current process getting executed. In such a case, the current process is preempted and the newly arrived process is scheduled to execute. Similar to SJF, FCFS is used to resolve the tie here.</p>
<h2>Largest Job First Scheduling</h2>
<h3>Description</h3>
<p>This is the opposite of Shortest Job First scheduling. 
It selects for execution the process with the largest execution time.
It can be preemptive or non preemptive.
</p>
<h3>Demerits</h3>
<p>1.The disadvantage with this algorithm is the total execution time of the process must be known before the  execution.<br>
There is a chance for starvation of processes which have lesser execution time  when the longer processes are continually added.<br>
</p>
<h2>Largest Remaining Time First Algorithm</h2>
<p>It is the preemptive version of the Largest job first scheduling.</p>
<h2>Non-preemptive priority scheduling</h2>
<h3>Description</h3>
<p>A more general case of the SJF scheduling where the priority was based on burst time. Each process is associated with a priority and CPU is allocated to the process with highest priority. Equal priority processes are scheduled in FCFS order. A newly arrived process is simply put in the ready queue based on its priority and does not interrupt the currently executing process.</p>
<h3>Demerits</h3>
<p>1.In a heavily loaded computer system, a steady stream of high priority processes can leave some low priority processes waiting for a long time. This is called as indefinite blocking or starvation.<br>
2.A solution to the problem of indefinite blocking is called aging, where priorities of processes that wait in the system for a long time are increased.<br></p>
<h2>Preemptive priority scheduling</h2>
<p>It is a preemptive version of the priority scheduling algorithm. The priority of newly arrived processes are compared with the currently executing process. If the priority is higher, then the currently executing process is preempted and the newly arrived process executes</p>
<h2>Round-Robin scheduling</h2>
<h3>Description</h3>
<p>
  The ready queue is treated as a circular queue. The CPU scheduler goes around the queue, allocating the CPU to each of the processes a time period of 1 quantum. If the burst time left for a process is less than the time quantum, then the process will itself release the CPU voluntarily. If the burst time left is more than 1 time quantum, the timer for that process will go off and a context switch is forced. This algorithm is preemptive by its nature.</p>
  <h3>Performance</h3>
  <p>1.Performance depends heavily on the time quantum. A very large time quantum will it make it effectively an FCFS algorithms and a very short time quantum will force a very large number of context switches.<br>
2.A rule of thumb is that 80% of the CPU bursts must be shorter than the time quantum.<br></p>
<h2>Highest Response Ratio Next</h2>
<h3>Description</h3>
<p>1.The response ratio of all the processes are calculated and the scheduler selects the process with the highest response ratio.<br>
2.A process once selected will run till its completion.<br>
3.Response ratio = (Waiting time so far + Burst Time)/Burst time.<br>
4.Shortest processes are favoured.
As the waiting time increases, the response ratio increases and the longer jobs can get past short jobs.<br>
</p>


</body>
</html>